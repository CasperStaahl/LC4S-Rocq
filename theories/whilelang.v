(* From HB Require Import structures. *)
(**)
(* (* SSReflect *) *)
(* From mathcomp Require Import ssreflect ssrfun ssrbool. *)
(* Set Implicit Arguments. *)
(* Unset Strict Implicit. *)
(* Unset Printing Implicit Defensive. *)
(**)
(* From mathcomp Require Import eqtype seq ssrnat. *)
(* From Lagois Require Import sem abssyn. *)
(**)
(* Inductive WhileExpSyntax := *)
(*   | wes_const (n : nat) *)
(*   | wes_var (i : ident) *)
(*   | wes_and (e1 : WhileExpSyntax)(e2 : WhileExpSyntax) *)
(*   | wes_or (e1 : WhileExpSyntax)(e2 : WhileExpSyntax). *)
(**)
(* Fixpoint WhileExpSem (μ : Store ident) (e : WhileExpSyntax) : nat := *)
(*   match e with *)
(*   | wes_const n => n *)
(*   | wes_var i => μ (loc i) *)
(*   | wes_and e1 e2 => (WhileExpSem μ e1) * (WhileExpSem μ e2) *)
(*   | wes_or e1 e2 => (WhileExpSem μ e1) + (WhileExpSem μ e2) *)
(*   end. *)
(**)
(* Inductive WhileSyntax := *)
(*   | ws_nop *)
(*   | ws_ass (i : ident) (e : WhileExpSyntax) *)
(*   (* | ws_while (e : WhileExpSyntax) (s : WhileSyntax) *) *)
(*   (* | ws_ite (e : WhileExpSyntax) (s1 : WhileSyntax) (s2 : WhileSyntax) *) *)
(*   | ws_cons (s1 : WhileSyntax) (s2 : WhileSyntax). *)
(**)
(* Inductive WhileSem : Semantic nat WhileSyntax := *)
(*   | wsem_nop μ : *)
(*       WhileSem μ ws_nop μ *)
(*   | wsem_ass μ i e : *)
(*       WhileSem μ (ws_ass i e) [eta μ with loc i |-> WhileExpSem μ e] *)
(*   (* | wsem_while_ff μ e s : *) *)
(*   (*     WhileExpSem μ e = 0 -> *) *)
(*   (*     WhileSem μ (ws_while e s) μ *) *)
(*   (* | wsem_while_tt μ μ' μ'' e s : *) *)
(*   (*     WhileExpSem μ e > 0 -> *) *)
(*   (*     WhileSem μ s μ' -> *) *)
(*   (*     WhileSem μ' (ws_while e s) μ'' -> *) *)
(*   (*     WhileSem μ (ws_while e s) μ'' *) *)
(*   (* | wsem_ite_ff μ μ' e s1 s2 : *) *)
(*   (*     WhileExpSem μ e = 0 -> *) *)
(*   (*     WhileSem μ s2 μ' -> *) *)
(*   (*     WhileSem μ (ws_ite e s1 s2) μ' *) *)
(*   (* | wsem_ite_tt μ μ' e s1 s2 : *) *)
(*   (*     WhileExpSem μ e > 0 -> *) *)
(*   (*     WhileSem μ s1 μ' -> *) *)
(*   (*     WhileSem μ (ws_ite e s1 s2) μ' *) *)
(*   | wsem_cons μ μ' μ'' s1 s2 : *)
(*       WhileSem μ s1 μ' -> *)
(*       WhileSem μ' s2 μ'' -> *)
(*       WhileSem μ (ws_cons s1 s2) μ''. *)
(* HB.instance Definition test := isBigStepSemantic.Build (Store nat) WhileSyntax WhileSem. *)
(**)
(* Fixpoint vars (e : WhileExpSyntax) : seq.seq Var := *)
(*   match e with *)
(*   | wes_const _ => [::] *)
(*   | wes_var i => [:: loc i] *)
(*   | wes_and e1 e2 *)
(*   | wes_or e1 e2 => (vars e1) ++ (vars e2) *)
(*   end. *)
(**)
(* Fixpoint determinesWhileAux (s : WhileSyntax) (determinesSoFar : Var -> seq.seq Var) : Var -> seq.seq Var := *)
(*   match s with *)
(*   | ws_nop => determinesSoFar *)
(*   | ws_ass i e => fun v => if v == loc i then flatten (map determinesSoFar (vars e)) else determinesSoFar v *)
(*   | ws_cons s1 s2 => let determinesSoFar' := determinesWhileAux s1 determinesSoFar in determinesWhileAux s2 determinesSoFar' *)
(*   end. *)
(**)
(**)
(* Definition determinesWhile (s : WhileSyntax) (v : Var) : seq.seq Var := (determinesWhileAux s (fun _ => [::])) v. *)
(**)
(* Fixpoint assignedWhile (s : WhileSyntax) (v : Var) : bool := *)
(*   match s with *)
(*   | ws_nop => false *)
(*   | ws_ass i e => match v with *)
(*                   | loc i' => if i == i' then true else false *)
(*                   | exp _ => false *)
(*                   | imp _ => false *)
(*                   end *)
(*   | ws_cons s1 s2 => assignedWhile s1 v || assignedWhile s2 v *)
(*   end. *)
(**)
(* Lemma frameWhile st st' (s : WhileSyntax) v: *)
(*   st ==[ s ]==> st' -> ~~ (assignedWhile s v) -> st v = st' v. *)
(* Proof. *)
(*   elim=> // [μ i e i_notass | μ μ' μ'' s1 s2 μ_s1_μ' IH1 μ'_s2_μ'' IH2 v_notass]. *)
(*   - case v_eq_loci: (v == loc i) => //=. *)
(*     move/eqP in v_eq_loci. *)
(*       by rewrite v_eq_loci /= eq_refl /= in i_notass. *)
(*     by rewrite v_eq_loci. *)
(*   - have v_notassin_s1_and_s2 : ~~ assignedWhile s1 v && ~~ assignedWhile s2 v *)
(*       by rewrite /= negb_or in v_notass. *)
(*     move: v_notassin_s1_and_s2 => /andP [v_notassin_s1 v_notassin_s2]. *)
(*     by rewrite -(IH2 v_notassin_s2) -(IH1 v_notassin_s1). *)
(* Qed. *)
(**)
(* Fixpoint readWhile (s : WhileSyntax) (v : Var) : bool := *)
(*   match s with *)
(*   | ws_nop => false *)
(*   | ws_ass i e => v \in vars e *)
(*   | ws_cons s1 s2 => readWhile s1 v || readWhile s2 v *)
(*   end. *)
(**)
(* Lemma readPWhile s (w' : Var) : reflect (exists w, w' \in determinesWhile s w) (readWhile s w'). *)
(* Proof. *)
(* Admitted. *)
(* (*   case w_readin_s : (readWhile s w'). *) *)
(* (*   Print reflect. *) *)
(* (*   - apply ReflectT. *) *)
(* (*     case: s w_readin_s => i //= e w'_in_varse. *) *)
(* (*     exists (loc i). *) *)
(* (*     by rewrite eq_refl. *) *)
(* (*   - apply ReflectF. *) *)
(* (*     move=> [w w'_in_detsw]. *) *)
(* (*     case: s w_readin_s w'_in_detsw  => [| i e w_readin_s w'_in_detsw ] //=. *) *)
(* (*     case: w w_readin_s w'_in_detsw => //= i'. *) *)
(* (*     case: (i == i') => //=. *) *)
(* (*     by move=> w'_notin_varse; rewrite w'_notin_varse. *) *)
(* (* Qed. *) *)
(**)
(* Lemma simple_securityWhile t z (μ μ' ν ν' : Store nat): *)
(*   assignedWhile t z -> *)
(*   μ ==[ t ]==> μ' -> *)
(*   ν ==[ t ]==> ν' -> *)
(*   (forall w, w \in determinesWhile t z -> μ w = ν w) -> *)
(*   μ' z = ν' z. *)
(* Proof. *)
(*   move=> z_assin_t μ_t_μ' ν_t_ν' μw_eq_νw_if. *)
(*   elim: μ_t_μ' ν_t_ν' z_assin_t μw_eq_νw_if => [ {}μ | {}μ i e ] ν_t_ν' z_assin_t μw_eq_νw_if; inversion ν_t_ν'; subst => //=. *)
(*   case z_eq_loci: (z == loc i); move/eqP in z_eq_loci. *)
(*   - elim: e ν_t_ν' z_assin_t μw_eq_νw_if => //. *)
(*     + move=> i' _ _ μw_eq_νw_if. *)
(*       apply: μw_eq_νw_if. *)
(*       rewrite z_eq_loci => /=. *)
(*       rewrite eq_refl. *)
(*       exact: mem_head. *)
(*     + move=> e1 H1 e2 H3 H4 H5 H6 => /=. *)
(*       rewrite {}H1. rewrite {}H3. by []. *)
(*       * exact: wsem_ass. *)
(*       * by rewrite z_eq_loci => //=; rewrite eq_refl. *)
(*       * by move=> /= w H7; apply H6 => /=; rewrite z_eq_loci eq_refl in H7 *; rewrite mem_cat; apply/orP; right. *)
(*       * exact: wsem_ass. *)
(*       * by rewrite z_eq_loci => //=; rewrite eq_refl. *)
(*       * by move=> /= w H7; apply H6 => /=; rewrite z_eq_loci eq_refl in H7 *; rewrite mem_cat; apply/orP; left. *)
(*     + move=> e1 H1 e2 H3 H4 H5 H6 => /=. *)
(*       rewrite {}H1. rewrite {}H3. by []. *)
(*       * exact: wsem_ass. *)
(*       * by rewrite z_eq_loci => //=; rewrite eq_refl. *)
(*       * by move=> /= w H7; apply H6 => /=; rewrite z_eq_loci eq_refl in H7 *; rewrite mem_cat; apply/orP; right. *)
(*       * exact: wsem_ass. *)
(*       * by rewrite z_eq_loci => //=; rewrite eq_refl. *)
(*       * by move=> /= w H7; apply H6 => /=; rewrite z_eq_loci eq_refl in H7 *; rewrite mem_cat; apply/orP; left. *)
(*   - apply: μw_eq_νw_if => /=. *)
(*     case: z z_eq_loci z_assin_t => //= i' loci'_neq_loci H1. *)
(*     move/eqP in loci'_neq_loci. *)
(*     rewrite/negb in loci'_neq_loci. *)
(*     rewrite/eqb in loci'_neq_loci. *)
(*     case i_eq_i': (i == i'); first last. *)
(*       by rewrite i_eq_i' in H1. *)
(*     move/eqP in i_eq_i'. *)
(*     by rewrite i_eq_i' eq_refl in loci'_neq_loci. *)
(* Qed. *)
(**)
(* Lemma xs_not_assignedWhile x t : ~~ (assignedWhile t (exp x)). *)
(* Proof. case: t => //=. Qed. *)
(**)
(* Lemma ys_not_assignedWhile y t : ~~ (assignedWhile t (imp y)). *)
(* Proof. case: t => //=. Qed. *)
(**)
(* HB.instance Definition _ := IsSubSemantic.Build nat WhileSyntax frameWhile readPWhile simple_securityWhile xs_not_assignedWhile ys_not_assignedWhile. *)
(**)
(**)
(**)
(**)
(**)
